namespace :cache do

  task :requirements => [:environment] do
    require 'importers/models/log'
  end

  task :print_info => [:requirements] do
    log.head "Cache"
    log.info "Dieser Task erneuert Caches."
    log.info ""
  end

  task :all => [
    :environment, :requirements, :print_info,
    :users,
    :memberships,
    :groups,
    :pages,
    :wbl_exports
  ]

  namespace :renew_later do

    # Die Tasks werden in umgekehrter Reihenfolge abgearbeitet: Was zuletzt aufgerufen wird,
    # wird zuerst erledigt. Das hat den Vorteil, dass der spätere Aufruf einen späteren Zeitstempel
    # hat: Wenn ein anderer Aufruf den gleichen Wert berechnen würde, aber zu einem früheren
    # Zeitstempel, dann wird er einfach übersprungen, weil bereits ein neuerer Wert vorliegt.
    #
    # Die Gruppen-Caches greifen auf die Caches der Wingolfiten zurück. Deswegen wäre es prima,
    # wenn die Wingolfiten-Caches dann bereits vorliegen, wenn die Gruppen-Caches erzeugt werden.
    # Da die zuletzt eingereihten Aufgaben zuerst ausgeführt werden, müssen die Caches, die zuerst
    # berechnet werden sollen, zuletzt eingereiht werden. Also müssen zuerst die Gruppen,
    # dann die Wingolfiten eingereiht werden.
    #
    task :all => [:groups, :wingolfiten]

    task :wingolfiten => [:requirements] do
      Group.alle_wingolfiten.members.each(&:renew_cache_later)
      log.success "Die Caches aller Wingolfiten werden nun im Hintergrund erneuert (Sidekiq)."
    end
    task :groups => [:requirements] do
      Group.all.each(&:renew_cache_later)
      log.success "Die Caches aller Gruppen werden nun im Hintergrund erneuert (Sidekiq)."
    end

    task :corporations => [:requirements] do
      Corporation.all.each(&:renew_cache_later)
      log.success "Die Caches aller Korporationen werden nun im Hintergrund erneuert (Sidekiq.)"
    end
  end

  # Call this with time parameter like this:
  #
  #     rake cache:renew
  #     rake cache:renew[1490450128]
  #
  # where the time index is generated by:
  #
  #     time.to_i
  #
  task :renew, [:time] => [:environment, :requirements] do |task, args|
    log.section "Cache erneuern"
    time = Time.at(args[:time].to_i) || Time.zone.now
    log.info "Time: #{time}, #{time.to_i}"
    Rails.cache.renew(time) do
      log.info "Groups:".blue
      Group.all.each { |obj| obj.fill_cache; print "." }
      log.info "\nPages:".blue
      Page.all.each { |obj| obj.fill_cache; print "." }
      log.info "\nUsers:".blue
      User.all.each { |obj| obj.fill_cache; print "." }
    end
    log.success "Finished."
  end

  task :users => [:environment, :requirements, :print_info] do
    log.section "Benutzer-Caches"

    # Load classes before reading those objects from cache.
    Corporation
    Flag
    AddressLabel
    Membership
    Bv

    User.find_each do |user|
      begin
        user.fill_cache

        print ".".green
      rescue => e
        print "F\n".red
        print "Error caching user #{user.id}: #{e.message}.\n".red
      end
    end
    log.success "\nFertig."
  end

  task :memberships => [:environment, :requirements, :print_info] do
    log.section "Benutzer-Gruppen-Mitgliedschaften"

    User.find_each do |user|
      user.memberships.each do |membership|
        begin
          membership.fill_cache
        rescue => e
          print "F\n".red
          print "Error caching membership #{membership.id}: #{e.message}.\n".red
        end
      end

      print ".".green
    end
    log.success "\nFertig."
  end

  task :groups => [:environment, :requirements, :print_info] do
    log.section "Gruppen"

    # Load classes before reading from cache.
    User
    Page
    NavNode
    Corporation

    Group.find_each do |group|
      begin
        group.fill_cache

        print ".".green
      rescue => e
        print "F\n".red
        print "Error caching group #{group.id}: #{e.message}.\n".red
      end
    end
    log.success "\nFertig."
  end

  task :pages => [:environment, :requirements, :print_info] do
    log.section "Inhaltsseiten"

    # Load classes before reading from cache.
    # ...

    Page.find_each do |page|
      begin
        page.fill_cache

        print ".".green
      rescue => e
        print "F\n".red
        print "Error caching page #{page.id}: #{e.message}.\n".red
      end
    end
    log.success "\nFertig."
  end

  task :wbl_exports => [:environment, :requirements, :print_info] do
    log.section "Exporte für die Wingolfsblätter"
    log.info "Siehe auch: https://wingolfsplattform.org/wbl \n"

    log.info "* Abonnenten-Adress-Liste für die Wingolfsblätter ..."
    @wbl_abo = Group.wbl_abo
    ListExports::Wingolfsblaetter.from_group(@wbl_abo).to_csv if @wbl_abo
    ListExports::Wingolfsblaetter.from_group(@wbl_abo).to_xls if @wbl_abo

    log.info "* Aktivenstatistik ..."
    @alle_aktiven = Group.alle_aktiven
    ListExport.new(@alle_aktiven, 'join_and_persist_statistics').to_csv if @alle_aktiven

    log.info "* Besondere Geburtstage ..."
    @philister = Group.alle_philister
    ListExports::SpecialBirthdays.from_group(@philister).to_csv if @philister
    ListExports::SpecialBirthdays.from_group(@philister).to_xls if @philister

    log.info "* Unsere Toten ..."
    @verstorbene = Group.alle_verstorbenen_wingolfiten
    ListExports::DeceasedMembers.from_group(@verstorbene).to_csv if @verstorbene
    ListExports::DeceasedMembers.from_group(@verstorbene).to_xls if @verstorbene

    log.success "\nFertig."
  end
end